# 아이템4. 인스턴스화를 막기위해 private 생성자를 사용한다.

### 정적 메서드, 정적 필드만을 담은 클래스
> `OutputView` 예로 들어보자. 
- 출력 문장에 관한 static 메서드를 모아둔다.
- 출력 문장은 static필드로 관리한다.
- 메서드 사용시 `OutputView.print...`로 사용한다.

이 외에도 `java.lang.Math`, `java.util.Arrays` 처럼 기본 타입 값, 배열 관련 메서드를 모아두거나

`java.util.Collections`처럼 `특정 인터페이스(List, Set, Map)를 구현하는 객체`를 생성하는 정적 메서드만 모아둘 수도 있다.
> _`java.util.Collections` 에는 get(), reverse(), shuffle(), isEmpty()등이 static 메서드로 구현되어 있다._

final 클래스와 관련된 메서드들을 모아둘 때에도 사용된다.
(final 클래스는 상속해 메서드를 하위 클래스에 넣는 것은 불가능)

### 생성자를 따로 선언하지 않으면 자동으로 pulic 생성자가 생기며, 인스턴스 생성을 막을 수 없다.
- 인스턴스로 만들려고 설계하지 않은 유틸리티 클래스를 인스턴스로 만들게 되면, 사용자가 인스턴스 클래스를 사용할 수도 있다.
- 추상 클래스로 만들더라도, 하위 클래스를 만들면 인스턴스화 가능하다.
### 예시
```java
public class UtilityClass{
    private UtilityClass(){
        throw new AssertionError();
    }
}
```
어떤 환경에서도 인스턴스화가 불가능한 클래스가 되었다.
- 명시적 생성자가 private라 외부 접근이 불가능하다.
- `AssertionError()`가 필수는 아니지만 클래스 안에서 실수로 생성자를 호출하는 경우를 방지해준다.
- 상속을 불가능하게 하는 효과는 덤이다. (상위 클래스의 생성자 호출이 불가능하니..)

