# 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

## 싱글턴
> 인스턴스를 오직 **하나만** 생성할 수 있는 클래스
> 
> stateless객체, 설계상 유일한 시스템 컴포넌트 등이 있다.

- 👍싱글턴은 인스턴스가 단 하나이기 때문에 인스턴스를 생성할때 드는 비용이 줄어드는 장점이 있지만,
- 👎싱글턴을 사용하는 클라이언트를 테스트하기 어렵다. (`mock` 필요)

## 싱글턴 생성 방식
### 1) public static 멤버를 final로 지정
```java
    public class System{
        public static final System instance = new System();
        private System(){
            // 단, 권한이 있는 클라이언트는 리플렉션API(ch65)로 private생성자를 호출 가능해 공격이 가능하다.
        }
    }
```
- private인 생성자는 `instance`를 초기화하며 단 한번만 수행되며 싱글톤을 보장한다.
- pubilc 필드로 해당 클래스가 싱글턴임을 명시할 수 있다.
- 간결하게 표현이 가능하며, `instance`가 final임으로 처음 생성된 하나의 객체만 참조한다.

### 2) 정적 팩터리 방식의 싱글턴
```java
    public class System{
        private static final System instance = new System();
        //public -> private로 변경되었다.
        private System(){
        }
        
        public static System getInstance(){ 
            return instance; 
            //무단 생성을 방지하기 위해 항상 같은 객체의 참조를 반환하도록 한다.
        }
    }
```
- API변경 없이 싱글톤을 해제할 수 있다.(getInstance 메서드를 스레드별로 다른 인스턴스로 넘겨주게 변경)
- 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다(ch30)
- getInstance 메서드를 supplier로 사용할 수 있다.
### 차이점
- 1번은 상대적으로 간편하지만, 공격의 위험성이 있다.
- 2번은 코드량이 길지만, 유연하게 변형이 가능하다는 장점이 있다.
### 공통점
- 생성자는 private, 인스턴스에 접근하는 수단으로 public static 멤버를 마련한다.
- 직렬화(Serializable)을 구현할때는 transient, readResolve 메서드를 제공해 싱글턴을 만족시켜줘야 한다.

```java
    private Object readResolve(){
        return instance;
    } //진짜 System인스턴스를 반환하고, 가짜는 가비지 컬렉터로 보낸다.
```
### 3) enum,열거 타입 방식
```java
    public enum System{
        INSTANCE;
        ..(추가함수)
    }
```
- public과 비슷하여, 간단하다.
- 직렬화에 추가 비용이 들지 않는다.
- 복잡한 직렬화, 리플렉션 공격등을 방지 가능하다.
- **원소가 하나뿐인 enum이 싱글톤을 만드는 가장 좋은 방법이다**
- 단, 싱글턴이 enum외의 클래스를 상속하려면 사용 할 수 없다. 