# 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라

### [아이템1](item1/오영선.md)에서 나온 생성자, 정적 팩토리에는 제약이 있다. 이 제약은 무엇이며, 어떻게 해결할 수 있을까?
> 💡매개변수가 많다면? 또, 매개변수의 종류를 선택할 수 있다면?
- 해당 문제에 대해, 위의 방식은 적절한 대응이 어렵다는 점이다.
- 예를 들어 식품 영양정보를 생성자, 정적 팩터리로 나타내보다.
- 여러가지 정보를 표현할 수 있지만, 필수 표기 정보를 제외한 대부분의 정보는 기본이 0이다.
#### 문제 - 정적 팩터리 메서드로 표현하기
```java
식품 영양 정보
    필수 표기
----------------
1회 내용량
총 n회 제공량,
1회 제공량 당 칼로리
    선택 표기
----------------
총 지방
트랜스 지방
포화지방
콜레스테롤
나트륨
        ..

public static NutritionFacts ofNeed(
        servingSize, amountPerServing, calories
        ){
        this(servingSize, amountPerServing, calories, 0, 0, 0,0..);
        }
public static NutritionFacts ofAll(
    servingSize, amountPerServing, calories, totalFat, cholesterol, ..
){
        this(servingSize, amountPerServing, calories, totalFat, cholesterol, 0,0..);
}
```
이 클래스의 인스턴스를 만드려면 원하는 매개변수를 모두 포함한 생성자를 선택하고, 남은 값은 사용자가 직접 0으로 지정해줘야 한다.

> ***만약 매개변수 최소길이가 100개라면? 1000개라면?***
- 생성자 패턴을 여러가지로 늘릴 수도 있겠지만, 매개변수가 늘어날 수록 클라이언트가 코드를 사용하거나 읽기 어려울 것이다.
- 이는 디버깅에도 어려움을 준다.

#### 대안 1. 자바빈즈 패턴 JavaBeans
- 매개 변수 없이 인스턴스를 받아와, `setter`를 통해 매개변수의 값을 지정한다.
```java
public NutritionFacts(){} //기본 생성자

public void setServingSize(value){
    this.servingSize = value;
        }
        ...
```
- 인스턴스를 만들기 쉽다.
- 클라이언트가 사용/읽기 쉬워졌다.
- **but**, 온전한 객체 하나를 만들기 위해 여러번의 메서드 호출이 필요하다
- 객체를 완성하기 전까지 일관성(consistency)가 무너진다. (생성자 한곳에서만 유효성을 확인하지 못해 디버깅이 어려워짐)
- 따라서 불변 인스턴스로 만들 수 없다.
#### 대안 2. 빌더 패턴 Builder
- 클라이언트는 필수 매개변수로 생성자를 호출한다.
- 생성자는 빌더 객체를 반환한다.
- 빌더객체가 제공하는 세터 메서드로 선택 매개변수를 설정한다.
- 마지막으로 build()를 호출해 온전한 객체를 얻는다.
```java
public class NutritionFacts(){
    
    public Builder(필수 매개변수){
        ..
    }
    public Builder calories(value){
        this.calories = value;
        return this;
    } //빌더가 제공하는 세터메서드
    public NutritionFacts builde(){
        return new NutritionFacts(this);
    }
}
```
- `NutritionFacts`는 불변을 보장한다.
- 매개변수의 기본값을 한 곳에서 관리하게 되었다.
- builder가 스스로를 반환해 연쇄 호출이 가능해졌다. (Builder.calories().sodium()...build())
- 사용/읽기가 쉽다.
- 유효성 검사의 경우, 빌더의 생성자와 매서드의 입력 사이, 빌더의 매개변수 필드 등을 검사한다.

#### Builder패턴 장점
- 계층적으로 설계된 클래스와 함께 쓰기 좋다.
- 추상 클래스-추상 빌더, 구체클래스-구체 빌더
- 각 하위(구체) 클래스의 build는 해당하는 하위 클래스를 반환하도록 선언한다.
- 클라이언트는 형변환에 신경쓰지 않고도 해당 패턴을 사용할 수 있다.
- 가변 인수(개수, 타입이 지정되지 않은 인수)를 하나의 메서드를 여러번 호출하게 해 해결할 수 있다.
```java
    //test는 List<Integer>를 변수로 가지고 있다고 설정
    Test test = new Test.Builder.
        addList(1).addList(2).addList(3)
        .build();
```
- 상당히 유연하다. 여러 객체를 만들거나, 매개변수에 따라 다른 객체를 만들수도 있다. 빌더 스스로 객체마다 다른 번호를 부여할 수 도 있다.
#### Builder패턴 단점
- 객체를 만들기 전에 Builder를 만든다. (코드양이 늘어날 수 있다)
- 성능이 민감한 상황에서, 권장되지 않는다.
- 매개변수가 4개 이상은 되는 상황에서 유용하다.
* 단, API는 시간이 지날수록 매개변수가 늘어나는 경향이 있음
* 이떄문에, 매개변수가 적더라도 빌더로 시작하는게 나을 수 있다.

> 불변 : 어떠한 변경도 허용하지 않는 것(불변식의 극단적인 예시)
>
> 불변식 : 프로그램 실행 중 반드시 만족하는 조건