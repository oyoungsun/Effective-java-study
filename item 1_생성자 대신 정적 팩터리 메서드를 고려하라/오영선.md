# 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

### java에서 객체 인스턴스를 클래스로부터 받아오는 방법
#### 1. public 생성자
#### 2. 정적 팩터리 메서드를 통한 생성자
- 클래스는 생성자 대신 정적 팩터리를 제공할 수 있다.
- 언제, 어느 인스턴스를 살아 있게 할지를 통제한다(instance-controlled)
- 싱글톤 패턴, 인스턴스화 불가, 불변 값 클래스의 `equals`를 보장 등의 활용이 가능하다.
#### 장점
> 1. 이름을 가질 수 있다
- 이름을 통해 객체의 특성을 쉽게 묘사한다.
> 2. 객체를 여러가지 방법으로 반환할 수 있다.
- 정적 팩터리 메서드는, 생성자와 달리 반드시 하나만 생성하지 않아도 된다.
> 호출할 때 마다 인스턴스를 새로 생성하지 않는다.
- 3. `Boolean.valueOf()`는 객체를 생성하지 않고 미리 생성해둔 인스턴스를 재활용한다.
- 생성 비용이 큰 경우, 객체가 자주 요청되는 상황에서 성능을 향상할 수 있다.
> 4. (부모 클래스라면) 반환 시 자식 객체를 반환할 수 있다. `엄청난 유연성`을 제공한다.
- 대표적인 자식클래스, impl같은 구현 클래스를 공개하지 않고 해당 객체를 반환한다.
- API를 작게 유지하게 한다. (인터페이스 기반 프레임워크)
- 자바 8 이후로, 인터페이스에 정적 메서드를 선언할 수 있어, 클라이언트는 얻은 객체를 인터페이스로만 다루게 되었다.
> 5. 매개변수에 따라 다른 클래스의 반환이 가능하다.
- 장점 2+4로, 하위타입이기만 하면 매번 다르게 반환이 가능하다.
- ex) `EnumSet`, 클라이언트는 팩터리(메서드)가 주는 객체가 어느 (하위)클래스인지 알 필요가 없다.
> ❓6. 정적 팩터리 메서드를 작성하는 시점에서는 반환 객체의 클래스가 존재하지 않아도 된다.
- 서비스 제공자 프레임워크(ex JDBC - 자바&DB연결API)의 근간이 된다.
- 당장 반환 객체 클래스가 없더라도, 특정 경로에서 인터페이스 구현체의 위치를 알려준다면 해당 객체를 읽어 생성할 수 있다.
  [* ❓서비스 제공자 프레임워크 관련 참고자료](https://sysgongbu.tistory.com/95)

#### 단점
> 상속, 하위 클래스 생성이 불가능 하다.
- public, protected생성자가 있어야 상속이 가능한데, 생성자를 private로 숨기고 정적 팩터리 메서드만 제공하는 경우 상속이 불가능하다.
- 단, 불변 타입으로 만들려면 이 제약이 장점이 되기도 한다.
> 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
- 클라이언트가 사용하기에는 좋더라도, 개발자 입장에서는 생성자와 달리 다른 이름을 사용하기 때문에 정적 팩토리 메서드 사용시에 해당 메서드 명을 반드시 알고 있어야 한다.
- 따라서 `메서드 이름 규약`을 따름으로써 이 문제를 어느정도 해결한다.
#### 정적 팩터리 메서드 명명방식
- `from` : 매개변수 1, 해당 타입 인스턴스 반환
- `of` : 매개변수 0~*, 적합한 타입 인스턴스 반환
- `valueof` : from, of의 더 자세한 버전
- `instance, getInstance` : 매개변수로 명시한 인스턴스 반환, 같은 인스턴스임을 보장x
- `create, newInstance` : 매개변수로 명시한 인스턴스 반환, 다른(새로운) 인스턴스임을 보장
- `get(Type : 반환할 타입 지정)` : get, 다른 클래스에 팩터리 메서드를 정의할때 사용
- `newType` : create, 다른 클래스에 팩터리 메서드를 정의할때 사용
  `BufferedReader br = Files.newBufferedReader(path)`
- `type` : `getType, newType`의 축약본
---
### 💡반드시 정적 팩토리 메서드를 써야하나요?
>정적 팩터리 메서드, public 생성자의 장단점을 이해하고 사용하되, 무작정 public 생성자를 호출하는 습관은 고치자!
---